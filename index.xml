<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mybooklog</title>
    <link>https://kk-karl.github.io/booklog/</link>
    <description>Recent content on mybooklog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2024-2099 mybooklog</copyright>
    <lastBuildDate>Sun, 28 Apr 2024 09:45:52 +0800</lastBuildDate>
    <atom:link href="https://kk-karl.github.io/booklog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GRPC学习及实践</title>
      <link>https://kk-karl.github.io/booklog/post/myblg12/</link>
      <pubDate>Sat, 27 Apr 2024 22:49:48 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg12/</guid>
      <description>GRPC学习及实践 RPC RPC 代指远程过程调用（Remote Procedure Call），它的调用包含了传输协议和编码（对象序列号）协议等等。允许运行于一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外地为这个交互作用编程。 RPC具有简单、通用、安全、效率的特点，可以基于 HTTP 协议进行调用。&#xA;GRPC相关安装 安装GRPC 1、go get方式&#xA;$ go get -u google.golang.org/grpc 2、通过github 进入$GOTPATH目录，新建google.golang.org目录，拉取golang在github上的镜像库：&#xA;$ cd /usr/local/go/path/src $ mkdir google.golang.org $ cd google.golang.org/ $ git clone https://github.com/grpc/grpc-go $ mv grpc-go/ grpc/ Protoc Plugin编译器插件安装 $ go get -u github.com/golang/protobuf/protoc-gen-go 将Protoc Plugin的可执行文件从 GOPATH中移动到𝐺𝑂𝑃𝐴𝑇𝐻中移动到GOBIN 下&#xA;$ which protoc-gen-go /usr/local/bin/protoc-gen-go Protocol Buffers v3安装 $ wget https://github.com/google/protobuf/releases/download/v3.5.1/protobuf-all-3.5.1.zip $ unzip protobuf-all-3.5.1.zip $ cd protobuf-3.5.1/ $ ./configure $ make $ make install $ protoc --version libprotoc 3.</description>
    </item>
    <item>
      <title>GO语言包管理</title>
      <link>https://kk-karl.github.io/booklog/post/myblg11/</link>
      <pubDate>Sat, 27 Apr 2024 22:33:02 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg11/</guid>
      <description>GO语言包管理 包介绍 包（package）是多个Go源码的集合，go语言有很多内置包，比如fmt，os，io等。&#xA;定义包 main包是一个可执行的包，只应用程序的入口包，编译完会生成一个可执行文件。&#xA;一个目录下的同级文件归属一个包。 包名可以不和文件夹的名字一样，包名不能包含-符号。&#xA;package 包名 可见性 如果想在一个包中引用另外一个包里的标识符（如变量、常量、类型、函数等）时，该标识符必须是对外可见的（public）。在Go语言中只需要将标识符的首字母大写就可以。&#xA;// 首字母小写，外部包不可见，只能在当前包内使用 var num = 10 //首字母大写外部包可见，可在其他包中使用 const Name = &amp;#34;ares&amp;#34; // 首字母小写，外部包不可见，只能在当前包内使用 type person struct { name string } type Student struct { Name string //可在包外访问的方法 class string //仅限包内访问的字段 } type Payer interface { init() //仅限包内访问的方法 Pay() //可在包外访问的方法 } // 首字母大写，外部包可见，可在其他包中使用 func Add(x, y int) int { return x + y } func age() { // 首字母小写，外部包不可见，只能在当前包内使用 var Age = 18 // 函数局部变量，外部包不可见，只能在当前函数内使用 fmt.</description>
    </item>
    <item>
      <title>技术目标</title>
      <link>https://kk-karl.github.io/booklog/post/myblg10/</link>
      <pubDate>Tue, 23 Apr 2024 13:57:10 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg10/</guid>
      <description>&#xA;技术发展目标 技术分析数字 </description>
    </item>
    <item>
      <title>阶段总结：</title>
      <link>https://kk-karl.github.io/booklog/post/myblg08/</link>
      <pubDate>Thu, 18 Apr 2024 23:39:23 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg08/</guid>
      <description>我的小说连载 超短篇小说 《幻影》 chapter 01： 崛起 &amp;ldquo;大鹏一日乘风起，扶摇直上九万里&amp;rdquo; 雨夜，淅沥沥的雨点敲打着房间的玻璃，发出滴答滴答的声音。在这个漆黑的夜晚，我睁开眼睛，发现周围一片漆黑，除了我，什么都没有。 黑暗中，突然闪过一个身影，我吓了一跳，那是一个穿着黑色衣服的男子，他正站在我房间的门口。 点点星光，在闪烁着，不停的在我房间的窗户上跳跃，发出刺耳的声音。&#xA;同时，夹杂着电闪雷鸣的轰隆声。让这个夜晚，显示那么的幽怖、不太平。&#xA;chapter 02： 超级瞳术 chapter 03： 幻影 chapter 04： 异界 chapter 05： 进化 chapter 06： 梦境 </description>
    </item>
    <item>
      <title>好用的在线工具集合</title>
      <link>https://kk-karl.github.io/booklog/post/myblg07/</link>
      <pubDate>Wed, 17 Apr 2024 08:52:47 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg07/</guid>
      <description>好用的在线工具集合（本人收集） 在线工具合集&#xA;websocket在线测试 在线测试&#xA;菜鸟教程&#xA;艺术字、二维码&#xA;在线unicode&#xA;property转yaml&#xA;MD5转换&#xA;电子书转换&#xA;ASCII 艺术字转换&#xA;JAVA17 doc文档&#xA;在线gif&#xA;ipv6检测&#xA;文心一言&#xA;阿里巴巴矢量库</description>
    </item>
    <item>
      <title>遇事不决，量子力学</title>
      <link>https://kk-karl.github.io/booklog/post/myblg06/</link>
      <pubDate>Tue, 16 Apr 2024 10:27:49 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg06/</guid>
      <description>遇事不决，量子力学 量子力学的奠基人玻尔，曾经说过这么一句话：「如果你第一次学量子力学认为自己懂了，那说明你还没懂。」 量子力学为什么会获得这么奇怪的一句评价？&#xA;因为量子理论看起来很像是一套玄学理论，经历过经典物理教育的人，很难在第一时间完全理解。 今天为了吹好这个伟大的牛，咱们把时间尺度拉长一点，就从科学的起源说起吧。&#xA;人类从诞生开始就一直在努力认识这个世界。 最早的认识充满了想象，后来逐渐演化成了「宗教」，用一套完备的神灵体系解释世界，比如为什么会打雷闪电，那是因为有雷公电母。&#xA;当然，这说法肯定不靠谱啊，聪明人很快就发现，老天下不下雨，跟你干了啥没半毛钱关系！&#xA;于是这帮聪明人就在思考「世界的本源是什么」、「东西为什么往下掉」，太阳为什么东升西落，如此等等。 不过早期的聪明人只是坐在办公室里靠头脑风暴研究世界的，而不是靠观察和实验。&#xA;可毕竟是聪明人嘛，时间长了，总还是能折腾出一些靠谱的说法，后来这种单纯的思辨就慢慢演化成了「哲学」。 但是问题还没解决啊，大家坐而论道，虽然这份工作很体面，可究竟谁对谁错呢，张三说世界在乌龟的背上，李四说天是方的地是圆的。 那他们就不能出门去验证一下吗？&#xA;当然不能了！ 土鳖才动手，君子只动口，这种风气夸张到什么程度呢？&#xA;亚里士多德认为「女性的牙齿比男性少」，就这么一个理论，竟然被奉为经典数百年，这几百年时间里就没人张嘴去数一数到底谁的牙齿多。 在很长一段时间，大家就是这么靠拍脑袋研究世界的。&#xA;一直拍到了 17 世纪，突然有个家伙灵光一闪，动手做起了实验，这人就是「伽利略」。 关于伽利略，你可能听说过比萨斜塔自由落体试验，伽利略在比萨斜塔上同时扔下了一大一小两个铁球，用来验证重的东西会不会比轻的东西下落速度更快。 伽利略是第一个系统地用实验来研究事物的人，这就是「科学」的雏形，所以伽利略很伟大，稳坐物理学排行榜第二梯队。&#xA;是不是觉得早生几百年，你我都是科学家？ 不要天真了，其实经常以负面形象出现的亚里士多德，绝对属于当时最聪明的人，时代局限性造成的「无知」不是无知。&#xA;咱们继续，各位，「世界是由金木水火土构成」，这个题目是哲学还是科学？科学和哲学在五百年前可真是一家人哦！伽利略去世后刚好一年，牛顿诞生！&#xA;如果你认为是牛顿三大定律成就了牛顿，那就大错特错了。 牛顿的代表作是《自然哲学的数学原理》，你看看这名字就说明了一切，说的就是自然哲学里包含的数学原理。&#xA;牛顿系统地把数学工具引入到研究中，在伽利略的基础上，不但动手做实验，还进一步用数学来解释实验现象，这才使「哲学」和「科学」彻底分开，揭开了经典物理学的序幕。&#xA;牛顿是第一个用系统的数学工具研究世界的人，这与伽利略用的简单数学工具有本质区别，所以牛顿更伟大，毫无争议的物理学史上头把交椅。 既然牛顿做了示范，其他人也不傻嘛，往后数百年，各式牛人不断用数学和实验研究这个世界的本质，逐渐构成了经典物理学大厦。&#xA;宗教、哲学、科学，三驾马车拉着人类文明向前飞奔。 科学的优势在于数学，数学可以让科学的理论精确描述，精确重复，迅速传播，这非常重要，你就可以在他人基础上进一步发展，所以科学在 300 年时间内快速成长。&#xA;而宗教往往需要靠「悟」，比如「心静自然凉」，你无法用数学精确描述这个过程，所以也就无法重复这个现象，那大家就很难验证与学习，因此这个理论很难发展。 最终，「科学」摧枯拉朽般统一了人类的认知，虽然最近几年西方反智主义盛行，但不影响科学的绝对主流地位。&#xA;如今，无数个科学公式和理论交织在一起，相互印证，相互利用，自洽地解释这个世界。&#xA;同学们注意，重点来了，什么是「自洽」？ 举个例子： 小姑娘，你体重多少？——50 公斤。 你怎么知道的？——用体重称称出来的。 这个称准吗？——弹簧已经校准了。 弹簧怎么校准的？——用标准砝码啊。 砝码哪里来？——标准体积的金属啊。 体积怎么量的？——用刻度尺啊。 刻度尺精度怎么样吗？——用激光校准。 ……&#xA;这个问题是无限循环的，不同的科学理论相互印证，但人类永远无法知道「小姑娘体重」这个真相。 就如警察破案，100 个证人和 1000证据，都完美无缺地相互解释，那么警察就认为这就是真相，至于真相到底是什么已经不重要了。&#xA;人类这样自洽地解释世界，会不会出错？&#xA;几十亿人，成千上万个理论，运行了三百年，从来没有出现丝毫的错误！ 对统计学稍微有点常识的人都知道，这个体系出错的概率实在太小了。 没错，但再小的概率还是意味着有可能。&#xA;这个「可能」就是「量子力学」和「相对论」，这两个令人叹为观止的理论将原先构建了几百年的经典物理学大厦彻底摧毁！&#xA;很多人不知道经典物理学的「经典」是什么意思，说白了，就是符合你想象的东西，比如：热学、力学、电磁学、光学、声学等，差不多就是中学的那些东西。&#xA;就算物理学得再差，肯定会有基本的科学常识，比如这发刊词中提到的，大家都认为车库的车不会瞬间移动到客厅来。这就是经典的含义，因为牛顿第一个掀开经典物理的序幕，所以经典物理也叫牛顿物理。&#xA;绕了一大圈，量子力学的故事就从这里开始。 19 世纪的最后一天，世界著名科学家齐聚一堂「总结旧世纪，展望新世纪」，这群智商最高的人做出了一个现在看来非常荒谬的结论：所有的科学都被咱搞的差不多了，天上飞的，地上跑的，水里游的，大到恒星，小到原子，看得见的，看不见的，都已经有了比较完备的理论解释。&#xA;当时原话是这么说的：「物理学大厦已经落成，就剩下一些敲敲打打的修饰工作，美丽而晴朗的天空只被两朵乌云笼罩」。然后这群自恋的人在感叹后人真幸福啊，都不需要干活了！ 这就是物理学著名的「两朵乌云」，当时的物理学家认为，所有的科学只剩下这两个问题还没解决。&#xA;现在我们再看亚里士多德，是不是觉得他也是一位好同学了？这叫时代局限性。 那么问题来了，什么样的乌云才能遮住所有人的眼睛？&#xA;第一朵乌云。 古人以为空间里什么都没有，近代科学知道是有空气的，声音的传播需要空气。 按照这个思路，是不是空间里还有其他不知道的东西，不然太阳光靠什么传到地球呢。 后来找来找去，也找不出个所以然。物理学家很难过，称之为物理学大厦的第一朵乌云。</description>
    </item>
    <item>
      <title>java导入SSL证书</title>
      <link>https://kk-karl.github.io/booklog/post/%E6%88%91%E7%9A%84%E8%AE%A1%E5%88%92%E7%9B%AE%E6%A0%87/</link>
      <pubDate>Mon, 15 Apr 2024 14:01:37 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/%E6%88%91%E7%9A%84%E8%AE%A1%E5%88%92%E7%9B%AE%E6%A0%87/</guid>
      <description>这个错误通常是由于您正在尝试连接到使用自签名证书或未经受信任的根证书颁发机构签发的证书的SSL站点。&#xA;要解决此问题，有以下几种方法：&#xA;01、导入SSL证书 将SSL证书导入到您的Java keystore中。可以使用keytool工具将证书添加到Java keystore。使用以下命令：&#xA;keytool -importcert -file certificate_file -alias alias_name -keystore keystore_file&#xA;其中certificate_file是您要导入的证书文件，alias_name是别名，keystore_file是Java keystore文件的路径和名称。&#xA;02、禁用证书验证 如果您不想导入证书，可以在您的Java代码中禁用SSL证书验证。这是不推荐的，因为这可能会带来安全风险。但是，如果您只是在开发环境中使用SSL站点，并且您知道站点是安全的，则可以使用以下代码禁用证书验证：&#xA;TrustManager[] trustAllCerts = new TrustManager[] {&#xD;new X509TrustManager() {&#xD;public java.security.cert.X509Certificate[] getAcceptedIssuers() {&#xD;return null;&#xD;}&#xD;public void checkClientTrusted(X509Certificate[] certs, String authType) {&#xD;}&#xD;public void checkServerTrusted(X509Certificate[] certs, String authType) {&#xD;}&#xD;}&#xD;};&#xD;SSLContext sc = SSLContext.getInstance(&amp;#34;SSL&amp;#34;);&#xD;sc.init(null, trustAllCerts, new java.security.SecureRandom());&#xD;HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); 03、更新Java证书存储库 如果您的Java证书存储库已过期或缺少必要的根证书颁发机构，则可能需要更新Java证书存储库。可以从各种证书颁发机构网站下载最新的根证书并将其添加到Java证书存储库中。&#xA;这些解决方案可能会因您的具体情况而异。如果您仍然无法解决问题，请查看日志以获取更多信息，并考虑联系站点管理员以获取帮助。</description>
    </item>
    <item>
      <title>基于Spring 5.0的响应式编程</title>
      <link>https://kk-karl.github.io/booklog/post/%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sun, 14 Apr 2024 23:34:11 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/%E6%88%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/</guid>
      <description>基于Spring 5.0的响应式编程 什么是响应式编程？ 响应式编程是一种编程范式，其核心思想是使用异步数据流来处理数据。它旨在解决传统编程中遇到的并发性和数据流的问题，并且适用于各种应用程序，包括Web应用程序、移动应用程序和IoT设备等。&#xA;在响应式编程中，您可以使用Observable对象来表示数据流。这些流可以是无限的，可以被观察者订阅并异步地处理数据。响应式编程强调使用数据流和变换来处理数据，而不是使用显式的控制流语句和变量。&#xA;Spring 5.0和响应式编程 Spring 5.0是Spring Framework的一个重要版本，引入了对响应式编程的支持。在Spring 5.0中，您可以使用Reactor项目提供的功能来实现响应式编程。&#xA;Reactor是一个基于Java 8的库，提供了一组用于响应式编程的操作符。Reactor操作符可以应用于Flux和Mono对象，这些对象分别表示多个值和单个值的响应式数据流。通过使用Reactor操作符，您可以轻松地将数据流转换为不同的形式，例如过滤数据、转换数据和合并数据流。&#xA;Spring 5.0引入了对WebFlux的支持，这是一种基于响应式编程的Web框架。WebFlux允许您使用响应式编程的方式处理Web请求和响应，并且能够提供非常高的并发性能和可伸缩性。&#xA;学习响应式编程和Spring 5.0 如果您想学习响应式编程和Spring 5.0，以下是一些资源可以帮助您入门：&#xA;Reactor Core官方文档 - Reactor库的官方文档，提供了有关Reactor操作符的详细信息以及如何使用它们来实现响应式编程的示例代码。&#xA;Spring Framework官方文档 - Spring Framework的官方文档，提供了有关Spring 5.0和WebFlux的详细信息，以及如何使用它们来实现响应式编程的示例代码。&#xA;响应式编程入门指南 - 一篇入门指南，介绍了响应式编程的概念以及如何在Java中实现响应式编程。&#xA;[Reactive&#xA;Building Reactive RESTful APIs using Spring WebFlux - 一篇教程，介绍了如何使用Spring WebFlux构建响应式的RESTful API。&#xA;除此之外，还有许多博客文章、视频教程和在线课程可以帮助您深入了解响应式编程和Spring 5.0的应用。建议您在学习过程中积极尝试实践，并使用Spring Boot创建简单的响应式应用程序。&#xA;基于Spring 5.0的响应式编程应用 在实际开发中，您可以使用Spring 5.0的响应式编程功能来构建高性能、高并发的应用程序。以下是一些示例应用：&#xA;Web应用程序 - 使用Spring WebFlux和响应式编程来处理Web请求和响应，可以提高Web应用程序的并发性和可伸缩性。 数据流处理 - 使用响应式编程来处理流式数据，例如从消息队列、传感器和其他数据源接收数据。通过使用响应式编程，可以轻松地处理大量的异步数据流。 服务间通信 - 使用Spring Cloud和响应式编程来构建微服务架构，可以实现高效的服务间通信和负载均衡。 总之，Spring 5.0的响应式编程功能可以帮助您构建高性能、高并发的应用程序。建议您在学习和使用响应式编程和Spring 5.0时，保持开放心态和积极探索精神，以获取最佳的开发体验和应用效果。&#xA;Spring 5.0的响应式编程的优势和挑战 Spring 5.0的响应式编程功能提供了许多优势和挑战。以下是一些值得注意的点：&#xA;优势 高性能和高并发 - 使用响应式编程，可以轻松地处理大量的异步数据流，并提高应用程序的并发性和可伸缩性。 响应式API - 响应式编程支持异步和反应式的API，可以更好地处理客户端请求和响应，并提供更好的用户体验。 适用于云计算 - 响应式编程是云原生应用程序的理想选择，可以支持容器化和微服务架构。 挑战 学习曲线 - 响应式编程需要一些时间来适应和掌握。需要学习的概念包括反应式流、反应式类型、反应式操作符等。 程序设计复杂性 - 响应式编程需要仔细考虑设计和实现，以避免复杂的程序结构和代码混乱。 资源消耗 - 响应式编程需要更多的资源，例如CPU和内存，以处理大量的异步数据流。 总结 Spring 5.</description>
    </item>
    <item>
      <title>CAS框架</title>
      <link>https://kk-karl.github.io/booklog/post/myblg05/</link>
      <pubDate>Sun, 14 Apr 2024 14:25:09 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg05/</guid>
      <description>1、背景介绍 单点登录：Single Sign On,简称SSO，SSO使得在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。&#xA;CAS框架：CAS（Central Authentication Service）是实现SSO单点登录的框架。&#xA;2、盗一张学习CAS绝大多都看过的图以及执行部分分析 注：已分不清原创，此处就不给出地址了。&#xA;从结构上看，CAS包含两个部分：CAS Server 和CAS Client需要独立部署，主要负责对用户的认证工作；CAS Client负责处理对客户端受保护资源的访问请求，需要登录时，重定向到CAS Server.图1是CAS最基本的协议过程：&#xA;CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web 请求，同时， CAS Client会分析HTTP 请求中是否包请求 Service Ticket( 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的，于是，CAS Client会重定向用户请求到CAS Server（ Step 2 ）。 Step 3是用户认证过程，如果用户提供了正确的Credentials， CAS Server 会产生一个随机的 Service Ticket ，然后，缓存该 Ticket ，并且重定向用户到CAS Client（附带刚才产生的Service Ticket）， Service Ticket 是不可以伪造的，最后， Step 5 和 Step6是 CAS Client 和 CAS Server之间完成了一个对用户的身份核实，用Ticket查到 Username ，因为 Ticket是 CAS Server 产生的，因此，所以 CAS Server 的判断是毋庸置疑的。&#xA;该协议完成了一个很简单的任务，所有与CAS的交互均采用SSL协议，确保ST和TGC的安全性。协议工作过程会有2此重定向过程，但是CAS Client与CAS Server之间进行ticket验证的过程对于用户是透明的。</description>
    </item>
    <item>
      <title>SimpleDateFormat的线程安全问题以及四种解决办法</title>
      <link>https://kk-karl.github.io/booklog/post/myblg04/</link>
      <pubDate>Sun, 14 Apr 2024 14:10:45 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg04/</guid>
      <description>SimpleDateFormat的线程安全问题以及四种解决办法 1.多线程环境下SimpleDateFormat的不安全问题: SimpleDateFormat的format方法实际操作的就是Calendar（Calendar变量也就是一个共享变量线程不安全）。&#xA;也正是因为每次在转化时间的时候foramat会先把时间set到calendar中，这样就会导致A线程读取到B线程的时间&#xA;image&#xA;image&#xA;我们来试一下： 定义两个全局常量&#xA;private static final String myDateStr = &amp;#34;2022-01-01&amp;#34;; private static final SimpleDateFormat dateFormat = new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;); //写一个测试方法： private static void test(Callable task) throws Exception { ExecutorService pool = Executors.newFixedThreadPool(10); List&amp;lt;Future&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; 10; i++) { Future future = pool.submit(task); list.add(future); } for (Future future : list) { System.out.println(future.get()); } pool.shutdown(); } //开始测试： public static void main(String[] args) throws Exception { test(()-&amp;gt;dateFormat.</description>
    </item>
    <item>
      <title>redis限流方案汇总</title>
      <link>https://kk-karl.github.io/booklog/post/myblg02/</link>
      <pubDate>Sun, 14 Apr 2024 13:47:36 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg02/</guid>
      <description>楔子 &amp;ldquo;限流&amp;quot;这种事情即使在生活中也很常见，比如我们银行办理业务，银行不可能给去的所有人同时服务，因为柜台就那么几个。所以可能一次只给5个人办理业务，其他的人只能在后面排队；再比如打饭等等，也是一样的道理。因为能提供服务的数量有限，所以必须要通过限流的方式。&#xA;在程序的层面上也是一样的，如果我们的系统只能支持10万人同时在线购物，但是某一天突然来了100万个用户，那么后果显然是服务器直接瘫痪。因此只能让&amp;quot;限流&amp;quot;的功能来维护，先让一部分用户进行购物，其它的人进行排队，这样就等保证整个系统进行运转了。&#xA;这里提一下微博，微博因为哪个明星出轨了，或者哪个明星恋爱官宣了，导致服务器挂掉不止一次了。这里也是因为人数骤增导致的，当然这只是表层的原因，关于背后详细的架构、以及为什么这种情况一出现微博就又可能会挂掉的原因，我可能会在其它的系列中说，这里先不谈，今天主要是谈限流。&#xA;这里立一个flag，要是哪天所有人都以为还是单身的胡歌在微博上突然官宣：&amp;ldquo;大家好，这是我的妻子xxx，我们昨天领证了，希望得到大家的祝福。&amp;quot;，然后再附带两人结婚照和结婚证，我跟你说微博必瘫痪，话就撂这了。&#xA;Redis如何实现限流功能 关于限流所用的算法有两个：漏桶算法、令牌算法。&#xA;漏桶算法 漏桶算法的灵感源于漏斗，如下图所示：&#xA;首先，如果让你实现一个限流的算法你要怎么做呢？我们可以规定一个时间，比如60s，在60s之内只能处理100个请求，如果超过了100个，那么就将多余的请求丢弃掉。但是这样存在一个问题：如果在10s内请求就已经100个，因此剩余的50s只能把再来的请求给丢弃掉。但是这100个请求又花了10s中就全部处理完了，那么剩余的40s做什么？显然这样做就存在这资源浪费的情况。于是可能有人想到使用队列的方式，设置队列的容量为100，任务处理完了就出队，然后等待处理的入队，这样就保证了资源的利用率，恭喜你，漏桶算法就是这么做的。&#xA;说实话从漏斗本身上想，也能猜出使用的是队列，一边进一边出。无论漏斗上面的水流有多少，漏斗下面的水都是均匀流出的。如果上面的水流量大于下面流出的水流量的话，那么漏斗会慢慢变满；反之，漏斗永远不会被装满，并一直流出。&#xA;漏桶算法的实现步骤是：先声明一个队列保存请求，这个队列相当于漏斗，当队列容量满了之后，就放弃新来的请求。然后执行的话则是通过声明另一个线程定期从队列中获取一个或多个任务执行，这样就实现了漏桶算法。&#xA;漏桶算法可以在编程语言这一层实现。&#xA;令牌算法 令牌算法指的是有一个程序以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的话则放弃执行。如下图所示：&#xA;这种令牌算法，我们也可以使用Python的threading模块来实现。&#xA;更好的限流方案 在Redis4.0，已经为我们实现了限流功能，并提供了原子的限流指令，再加上Redis这个天生的分布式程序就可以完美地实现限流了。&#xA;实现限流需要使用Redis提供的Redis-Cell模块，该模块使用的便是漏桶算法，使用起来也很简单，通过cl.throttle即可，但是我们需要提前安装。&#xA;前往：https://github.com/brandur/redis-cell/releases下载对应系统的安装包，有源码编译和安装包安装两种方式，源码编译需要rust环境、比较复杂，所以推荐安装包安装。安装之后，直接解压即可，里面会有一个libredis_cell.so文件，执行redis-cli通过module load加载即可。&#xA;&amp;gt; cl.throttle mylimit 15 30 60 1）（integer）0 # 0 表示获取成功，1 表示拒绝 2）（integer）15 # 漏斗容量 3）（integer）14 # 漏斗剩余容量 4）（integer）-1 # 被拒绝之后，多长时间之后再试（单位：秒）-1 表示无需重试 5）（integer）2 # 多久之后漏斗完全空出来 其中 15 为漏斗的容量，30 / 60s 为漏斗的速率。&#xA;通过Redis-Cell，我们则可以实现分布式原子级别的限流，更详细的使用可以查看官网</description>
    </item>
    <item>
      <title>RocketMQ学习</title>
      <link>https://kk-karl.github.io/booklog/post/myblg03/</link>
      <pubDate>Thu, 11 Apr 2024 13:47:41 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg03/</guid>
      <description>MQ有什么用 解耦 我觉得从某种角度来说，微服务促进了MQ的蓬勃发展，本来一个系统有N多个模块，所有模块都强耦合在一起，现在微服务了，一个模块就是一个系统，系统之间肯定需要交互，交互有三种常见的方法，一种是RPC，一种是HTTP，一种就是MQ了。&#xA;异步 原本一个业务分为N步，要一步一步处理，才能把最终的结果返回给用户，现在有了MQ，先把最关键的部分处理完毕，然后发送消息到MQ，直接返回给用户OK，至于后面的步骤在后台慢慢处理吧，真乃提升用户体验的神器。&#xA;削峰 某个接口的请求量突然飙升，势必会对应用服务器、数据库服务器造成很大的压力，现在有了MQ，来多少请求都不在怕的，后台慢慢处理呗。&#xA;RocketMQ简介 RocketMQ是用Java编写的，是阿里开源的消息中间件，吸收了Kafka很多优点。Kafka也是比较热门的消息中间件，不过Kafka是用Scala编写的，不利于Java程序员去阅读源码，也不利于Java程序员做一些定制化的开发。接触过Kafka的小伙伴都知道，要用好Kafka实属不易，相对来说，RocketMQ简单多了，而且RocketMQ有阿里加持，经历了N次双11的考验，比较适合国内互联网公司，所以国内使用RocketMQ的公司很多。&#xA;RocketMQ四大组件 图片来自https://gitee.com/mirrors/rocketmq/blob/master/docs/cn/architecture.md&#xA;可以看到RocketMQ主要有四个组件：&#xA;NameServer 无状态服务，注册中心，可集群部署，但是NameServer节点之间没有任何数据交互。 Broker会以定时把Topic路由信息上报给所有的NameServer。Producer、Consumer会随机选择一个NameServer定时Topic更新路由信息。 Topic路由信息在NameServer集群中采用最终一致性。 保证AP。 Broker RocketMQ的服务端，用于存储消息、分发消息。 Broker会定时把自身拥有的所有的Topic路由信息上报给NameServer。 Broker有两个角色：Master、Follower，Master承担读（消费消息）写（生产消息）操作，如果Master比较忙，或者不可用，Follower可以承担读操作。BrokerId=0，代表是Matser，BrokerId!=0，代表是Follower，需要注意的有两点： 其一，目前为止，BrokerId=1的Follower才可以承担读操作； 其二，只有较高版本的RocketMQ才支持当Master节点挂掉，Follower自动升级到Master。 Producer 生产者，每隔一定时间向NameServer发起Topic的路由信息查询。&#xA;Consumer 消费者，每隔一定时间向NameServer发起Topic的路由信息查询。&#xA;为什么注册中心不选用Zookeeper 其实，在低版本的RocketMQ中，确实是选用Zookeeper作为注册中心的，但是后面改成了现在的NameServer，猜想主要原因是：&#xA;RocketMQ已经是一个中间件了，不想再依赖其他中间件。 Zookeeper比较重，有很多功能RocketMQ是用不到的，不如写一个轻量级的注册中心。 Zookeeper是CP，一旦触发领导选举，那么注册中心就不可用了，而RocketMQ的注册中心，不需要强一致性，只要保证最终一致性。 RocketMQ消息领域模型 Message 传输的消息。 消息必须有Topic。 消息可以有多个Tag和多个Key，可以看做消息的附加属性。 Topic 一类消息的集合。 每个消息必须有一个Topic。 消息的第一级类型。 Tag 一个消息除了有Topic之外，还可以有Tag，用来细分同一个Topic下的不同种类的消息。 Tag不是必须的。 消息的第二级类型。 Group 分为ProducerGroup，ConsumerGroup，我们更多的是关注ConsumerGroup，ConsumerGroup包含多个Consumer。&#xA;在集群消费模式下，一个ConsumerGroup下的Consumer共同消费一个Topic，且每个Consumer会被分配到N个队列，但是一个队列只会被一个Consumer消费，不同的ConsumerGroup可以消费同一个Topic，一条消息会被订阅此Topic的所有ConsumerGroup消费。&#xA;Queue 一个Topic默认包含四个Queue。 在集群消费模式下，同一个ConsumerGroup中的Consumer可以消费多个Queue的消息，但是一个Queue只能被一个Consumer消费。 Queue中的消息是有序的。 分为读Queue和写Queue，一般来说，读Queue的数量和写Queue的数量是一致的，否则很容易出问题。 消费模式 消费模式有两种：Clustering（集群消费）和Broadcasting（广播消费）。&#xA;和其他MQ不同，其他MQ是在发送消息的时候，指定是集群消费还是广播消费，RocketMQ是在消费者端设置是集群消费还是广播消费。&#xA;Clustering（集群消费） 默认情况下是集群消费模式，该模式下，ConsumerGroup所有的Consumer共同消费一个Topic的消息，每个Consumer负责消费N个队列的消息（N也可能为1，甚至是0，没有分配到队列），但是一个队列只会被一个Consumer消费。如果某个Consumer挂掉，ConsumerGroup下的其他Consumer会接替挂掉的Consumer继续消费。&#xA;集群消费模式下，消费进度维护在Broker端，存储路径为${ROCKET_HOME}/store/config/ consumerOffset.json，如下图所示： 使用topicName@consumerGroupName为Key，消费进度为Value，Value的形式是queueId:offset ，说明如果有多个ConsumerGroup，每个ConsumerGroup的消费进度是不同的，需要分开来存储。&#xA;Broadcasting（广播消费） 广播消费消息会发给ConsumerGroup中所有的Consumer。&#xA;广播消费模式下，消费进度维护在Consumer端。&#xA;消费队列负载算法与重平衡机制 消费队列负载算法 我们知道了在集群消费模式下，ConsumerGroup下所有的Consumer共同消费一个Topic的消息，每个Consumer负责消费N个队列的消息，那么具体是如何分配的呢？这就涉及到消费队列负载算法了。&#xA;RocketMQ提供了众多的消费队列负载算法，其中最常用的是两种算法，即AllocateMessageQueueAveragely、AllocateMessageQueueAveragelyByCircle。下面我们来看下这两个算法的区别。&#xA;假设，现在一个Topic有16个队列，用q0~q15表示，有3个Consumer，用c0-c2表示。</description>
    </item>
    <item>
      <title>基于Spring 5.0的响应式编程</title>
      <link>https://kk-karl.github.io/booklog/post/myblg01/</link>
      <pubDate>Sun, 31 Dec 2023 12:20:34 +0800</pubDate>
      <guid>https://kk-karl.github.io/booklog/post/myblg01/</guid>
      <description>标题 学习目标 基于Spring 5.0的响应式编程 什么是响应式编程？ 响应式编程是一种编程范式，其核心思想是使用异步数据流来处理数据。它旨在解决传统编程中遇到的并发性和数据流的问题，并且适用于各种应用程序，包括Web应用程序、移动应用程序和IoT设备等。&#xA;在响应式编程中，您可以使用Observable对象来表示数据流。这些流可以是无限的，可以被观察者订阅并异步地处理数据。响应式编程强调使用数据流和变换来处理数据，而不是使用显式的控制流语句和变量。&#xA;Spring 5.0和响应式编程 Spring 5.0是Spring Framework的一个重要版本，引入了对响应式编程的支持。在Spring 5.0中，您可以使用Reactor项目提供的功能来实现响应式编程。&#xA;Reactor是一个基于Java 8的库，提供了一组用于响应式编程的操作符。Reactor操作符可以应用于Flux和Mono对象，这些对象分别表示多个值和单个值的响应式数据流。通过使用Reactor操作符，您可以轻松地将数据流转换为不同的形式，例如过滤数据、转换数据和合并数据流。&#xA;Spring 5.0引入了对WebFlux的支持，这是一种基于响应式编程的Web框架。WebFlux允许您使用响应式编程的方式处理Web请求和响应，并且能够提供非常高的并发性能和可伸缩性。&#xA;学习响应式编程和Spring 5.0 如果您想学习响应式编程和Spring 5.0，以下是一些资源可以帮助您入门：&#xA;Reactor Core官方文档 - Reactor库的官方文档，提供了有关Reactor操作符的详细信息以及如何使用它们来实现响应式编程的示例代码。&#xA;Spring Framework官方文档 - Spring Framework的官方文档，提供了有关Spring 5.0和WebFlux的详细信息，以及如何使用它们来实现响应式编程的示例代码。&#xA;响应式编程入门指南 - 一篇入门指南，介绍了响应式编程的概念以及如何在Java中实现响应式编程。&#xA;[Reactive&#xA;Building Reactive RESTful APIs using Spring WebFlux - 一篇教程，介绍了如何使用Spring WebFlux构建响应式的RESTful API。&#xA;除此之外，还有许多博客文章、视频教程和在线课程可以帮助您深入了解响应式编程和Spring 5.0的应用。建议您在学习过程中积极尝试实践，并使用Spring Boot创建简单的响应式应用程序。&#xA;基于Spring 5.0的响应式编程应用 在实际开发中，您可以使用Spring 5.0的响应式编程功能来构建高性能、高并发的应用程序。以下是一些示例应用：&#xA;Web应用程序 - 使用Spring WebFlux和响应式编程来处理Web请求和响应，可以提高Web应用程序的并发性和可伸缩性。 数据流处理 - 使用响应式编程来处理流式数据，例如从消息队列、传感器和其他数据源接收数据。通过使用响应式编程，可以轻松地处理大量的异步数据流。 服务间通信 - 使用Spring Cloud和响应式编程来构建微服务架构，可以实现高效的服务间通信和负载均衡。 总之，Spring 5.0的响应式编程功能可以帮助您构建高性能、高并发的应用程序。建议您在学习和使用响应式编程和Spring 5.0时，保持开放心态和积极探索精神，以获取最佳的开发体验和应用效果。&#xA;Spring 5.0的响应式编程的优势和挑战 Spring 5.</description>
    </item>
  </channel>
</rss>
